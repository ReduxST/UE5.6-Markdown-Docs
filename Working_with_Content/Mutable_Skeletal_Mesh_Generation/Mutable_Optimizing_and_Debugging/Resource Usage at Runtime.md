# Resource Usage at Runtime

**Source:** [https://dev.epicgames.com/documentation/en-us/unreal-engine/mutable-resource-usage-at-runtime-in-unreal-engine](https://dev.epicgames.com/documentation/en-us/unreal-engine/mutable-resource-usage-at-runtime-in-unreal-engine)  
**Processed:** 2025-06-14 16:37:53

---

This section is relevant for projects using Mutable at runtime. If your project is using a workflow that uses Mutable only in the Unreal Editor, then there is no additional resource usage.

When used at runtime to create assets from CustomizableObjects, Mutable is a plugin and requires the following additional resources to run:

-   CPU time:
    -   Most of the CPU loading time is in worker threads. This uses the Unreal Task system to split the work in multiple tasks.
    -   Small parts of the work also happen in the game thread. These must be small enough to avoid hitches.
-   Memory:
    -   Final assets generated by Mutable are standard Unreal Engine resources (textures, skeletal meshes, animation blueprints, etc.).
    -   While building these resources, Mutable needs "working memory" for its intermediate operations.
-   Disk Streaming Bandwidth:
    -   Mutable loads its own data during the on-going construction of a character. This uses the Unreal disk streaming system.

There are Unreal Insights channels for Mutable both for CPU and memory usage. They are toggled off by default but enabling them in captures gives a good idea of the work done at runtime.

## Mutable Operations

All Mutable operations (instance generation or update) work in sequence: there are never 2 operations happening at the same time. For this reason, all operations are treated as asynchronous and there are callbacks to notify when they are complete.

An explicit call will force its update when the parameters of a CustomizableObjectInstance are changed. When Mutable has completed the update operation, the engine resources are created or replaced.

Mutable can be integrated with Unreal's texture streaming functionality. When doing this, Mutable queues work whenever a new texture mipmap is requested by the texture streaming system. This also happens sequentially with normal instance updates.

## Memory and Caches

The amount of working memory used by Mutable depends directly on the CustomizableObject being built. An estimation of the upper limit is roughly 2 times the memory of the biggest generated texture in uncompressed format, or the biggest mesh. This depends on the operations done to the textures, the use of UV layout blocks, or the CustomizableObject compilation settings.

Mutable does try to keep working memory under a certain limit. This limit can be specified in the INI files per-platform, but some projects may be interested in controlling it for different in-game scenarios. For example, you may want to give Mutable more memory to cache data and speed up instance updates when players are in a character creation screen. In this use case, it can be set directly with the `UCustomizableObject::SetWorkingMemory` method, or the `mutable.WorkingMemory` cvar.